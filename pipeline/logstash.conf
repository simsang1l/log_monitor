input {
  file {
    path => "/data/ssh-*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    mode => "tail"
  }
}

filter {
  grok {
    match => { "message" => "%{SYSLOGTIMESTAMP:log_time} %{GREEDYDATA:msg}" }
  }
  # source_path 복사 + source_file 추출
  ruby {
    code => "
      if event.get('[log][file][path]')
        full = event.get('[log][file][path]')
        event.set('source_path', full)
        event.set('source_file', File.basename(full))
      end
      event.set('log_type', 'ssh')
    "
  }
  # source_file에서 연도 추출 (예: ssh-20240101.log)
  grok {
     match => { "source_file" => "ssh\-(?<log_year>\d{4})(?<log_month>\d{2})(?<log_day>\d{2})\.log" }
     tag_on_failure => []
   }
  ruby {
     code => "
       y = event.get('log_year')
       m = event.get('log_month')
       d = event.get('log_day')
       t = event.get('log_time')
       if y and m and d and t
         event.set('event_time', y + '-' + m + '-' + d + ' ' + t)
       end
     "
   }
  date {
    match => [ "event_time", "YYYY-MM-dd MMM dd HH:mm:ss", "YYYY-MM-dd MMM  d HH:mm:ss", "YYYY-MM-dd HH:mm:ss" ]
    target => "event_time"
  }
  
  # 불필요한 필드 제거
  mutate {
    remove_field => ['@version', 'host', 'tags', 'event', 'log', 'log_day', 'log_year', 'log_month']
  }
  
  fingerprint {
    source => ["source_path", "message"]
    target => "row_hash"
    method => "SHA256"
  }
}

output {
  kafka {
    bootstrap_servers => "kafka1:29092"
    topic_id => "ssh-log"
    codec => json
    acks => "all"
  }
}